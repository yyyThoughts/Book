
## 7장 분산 시스템을 위한 유일 ID 생성기 설계

**작성일** : 2022.07.21

- auto_increment 속성이 설정된 관계형 데이터베이스의 기본 키? 분산 환경

### 1단계 문제 이해 및 설계 범위 확정

- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있었야 한다.

### 2단계 개략적 설계안 제시 및 동의 구하기

#### 다중 마스터 복제

- 데이터베이스의 auto_increment 기능을 활용. 다만, 다음 ID의 값을 구할 때 1만큼 증가시켜 얻는 것이 아니라, k만큼 증가시킨다.
- 단점
	- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
	- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
	- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

#### UUID(Universally Unique Identifier)

- UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수다.
- 장점
	- UUID를 만드는 것은 단순하다. 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
	- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.
- 단점
	- ID가 128비트로 길다. 이번 장에서 다루는 문제의 요구사항은 64비트다.
	- ID를 시간순으로 정렬할 수 없다.
	- ID에 숫자 아닌 값이 포함될 수 있다.

#### 티켓 서버

- 이 아이디어의 핵심은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것
- 장점
	- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
	- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.
- 단점
	- 티켓 서버가 SPOF가 된다. 여러 대의 티켓 서버를 준비한다면, 데이터 동기화같은 새로운 문제가 발생할 수 있다.

#### 트위터 스노플레이크 접근법

- 64비트의 ID 구조
	- 1비트의 사인, 41비트의 타임스탬프, 5비트의 데이터센서 ID, 5비트의 서버 ID, 12비트의 일련번호
- 데이터센서 ID와 서버 ID는 시스템이 사작할 때 결정. 이들을 잘못 벼경하게 되면 ID 충돌이 발생할 수 있다.

##### 타임스탬프

- 시간이 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간순으로 정렬 가능하게 됨

##### 일련번호

- 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

### 4단계 마무리

- 이번 장에는 유일성이 보장되는 ID 생성기 구혀에 쓰일 수 있는 다양한 전략을 살펴봄
	- 다중 마스터 복제
	- UUID
	- 티켓 서버
	- 트위터 스노플레이크
- 추가 논의 사항
	- 시계 동기화: Network Time Protocol이 이 문제를 해결하는 가장 보편적인 수단
	- 각 절의 길이 최적화: 동시성이 낮고 수명이 긴 애플리케이션ㅇ이라면 일련번호 절의 길이를 줄이고 타임스템프 절의 길이를 늘리는 것이 효과적일 수 있을 것이다.


-------------------------------------------------------

### 궁금한 내용이나, 더 알아보고 싶은 내용을 적어봅시다 🤔
```


