## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.07.12

**오늘 읽은 범위** : 

### 3줄 요약 📑

+ 요약1
+ 요약2
+ 요약3

---

### 1장 계층형 아키텍처의 문제는 무엇일까?

#### 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

- 소프트웨어는 상태가 아니라 행동을 중심으로 모델링해야 한다. 
- 그러나 그동안 만들어 본 애플리케이션의 유스케이스를 한번 떠올려보자. 데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현했을 것이다.
- 비즈니스 관점에서는 전혀 맞지 않는 방법이다. 다른 무엇보다도 도메인 로직을 먼저 만들어야 한다.

#### 지름길을 택하기 쉬워진다.

- 전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다.
- 그러나 개발이 진행될 수록, 지금길(꼼수)에 의해 영속성 계층이 비대해 질 것이다.
- 그러니 아키텍처의 '지름길 모드'를 끄고 싶다면, 적어도 추가적인 아키텍처 규칙을 강제하지 않는 한 계층은 최선의 선택은 아니다.

#### 테스트하기 어려워진다.

- 계층형 아키텍처를 사용할 떄 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다. 이러한 일이 자주 일어난다면 두 가지 문제점이 생긴다.
	- 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 된다는 것이다.
	- 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야 한다는 것이다.
- 시간이 흘러 웹 컴포넌트의 규모가 커지면 다양한 영속성 컴포넌트에 의존성이 많이 쌓이면서 테스트의 복잡도를 높인다.


#### 유스케이스를 숨긴다.

- 계층형 아키텍처에서는 도메인 서비스의 '너비'에 관한 규칙을 강제하지 않는다. 넓은 서비시는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존.  

#### 동시 작업이 어려워진다.

- 인원을 더 투입하여 더 빨리 프로젝트를 마치고 싶다면? 아키텍처가 이를 지원해야 함. 그러나 계층형 아키텍처는 이런 측면에서는 그다지 도움이 되지 않는다.

#### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

- 올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있게 된다.
- 그러나 앞에서 살펴봤듯이 계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다.
- 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.

-------------------------------------------------------

### 2장 의존성 역전하기

#### 단일 책임 원칙

```
단일 책임 원칙: 컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.
```
- 안타깝게도 변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 너무도 쉽게 전파된다.

#### 부수효과에 관한 이야기

```
부수효과: 
```


#### 의존성 역전 원칙

- 계층형 아키텍처에서 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드는 애플리케이션에서 가장 중요한 코드다. 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꾸고 싶지는 않다.
- 의존성 역전 원칙을 적용하여, 영속성 계층이 도메인 계층에 의존하도록 의존성을 역전시킨다.

```
의존성 역전 원칙: 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.
```

#### 클린 아키텍처

- 이 아키텍처에서 가장 주요한 규칙은 의존성 규칙으로, 계층 간의 모든 의존성이 안쪽으로 향해야 한다는 것이다.
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다. 그래서 도메인 코드를 자유렙게 모델링할 수 있다.
- 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.

#### 육각형 아키텍처

- 육각형 모양은 사실 아무 의미도 없다. 다른 시스템이나 어댑터와 연결되는 4개 이상의 면을 가질 수 있음을 보여주기 위해 일반적인 사각형 대신 육각형을 사용했다고 한다.
- 육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 없기 때문에 마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용한다는 점을 주목하자. **대신 모든 의존성은 코어를 향한다.**
- 육각형의 왼쪽에 있는 어댑터들은 애클리케이션을 주도하는 어댑터들이다. 반면에 오른쪽에 씨는 어댑터들은 애플리케이션에 의해 주도되는 어댑터들이다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다.

-------------------------------------------------------

### 3장 코드 구성하기

#### 계층으로 구성하기

- 적어도 세 가지 이유로 이 패키지 구조는 최적의 구조가 아니다.
	- 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다.
	- 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
	- 패키지 구조를 통해서는 우리가 목표로 하는 아키텍처를 파악할 수 없다.

#### 기능으로 구성하기

- 기능에 의한 패키징 방식은 사실 계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 더 떨어뜨린다.

#### 아키텍처적으로 표현력있는 패키지 구조

- 육각형 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터다.
- 이처럼 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진한다. 많은 패키지가 생기고, 현재 작업 중인 코드를 어떤 패키지에 넣어야 할지 계속 생각해야 하기 때문이다.
- 어댑터 코드를 자체 패키지로 이동시키면 필요할 경우 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다는 장점도 있다.
- 모든 구조와 마찬가지로 패키지 구조를 소프트웨어 프로젝트 내내 유지하기 위해서는 지켜야할 규칙이 있다.


#### 의존성 주입의 역할

- 클린 아키텍처의 가장 본질적인 요건은 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.
- 인커밍 어댑터에 대해서는 그렇게 하기가 쉽다.
- 아웃고잉 어댑터에 대해서는 제어 흐름의 반대 방향으로 의존성을 돌리기 위해 **의존성 역전 원칙을 이용**해야 한다.
- 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까? 이 부분에서 **의존성 주입**을 활용할 수 있다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 육각형 아키텍처의 패키지 구조를 통해 코드에서 아키텍처의 즉정 요소를 찾으려면 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다.


-------------------------------------------------------


### 4장 유스케이스 구현하기

#### 도메인 모델 구현하기

- Account 엔티티 구현

#### 유스케이스 둘러보기

- 일반적으로 유스케이스는 다음과 같은 단계를 따른다.
	1. 입력을 받는다
	2. 비즈니스 규칙을 검증한다.
	3. 모델 상태를 조작한다.
	4. 출력을 반환한다.
- 유스케이스는 비즈니스 규칙을 검증할 책임이 있음. 그리고 도메인 엔티티와 이 책임을 공유한다.

#### 입력 유효성 검증

- 애플리케이션 계층에서 입력 유효성을 검증해야 하는 이유는, 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.
- 입력 유효성 검증은 유스케이스 로직의 일부가 아니기 때문에, 입력 모델을 이용하여 입력 유효성 검증

#### 생성자의 힘

- 빌더 패턴은 코드의 일관성에 문제를 일으킬 수 있다.

#### 유스케이스마다 다른 입력 모델

- 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다. 물론 비용이 안 드는 것은 아니다. 들어오는 데이터를 각 유스케이스에 해당하는 입력 모델에 매핑해야 하기 때문이다.

#### 비즈니스 규칙 검증하기

- 언제 입력 유효성을 검증하고 언제 비즈니스 규칙을 검증해야 할까?
- 둘 사이의 아주 실용적인 구분점은 비즈니스 규칙을 검증하는 것은 도메인 모델의 현재 상태에 접근해야 하는 반면, 입력 유효성 검증은 그럴 필요가 없다는 것이다.
- 비즈니스 규칙은 도메인 엔티티의 상태를 필요로 하기 때문에, 도메인 엔티티 안에 넣는 것이 좋은 방법이다. 

#### 풍부한 도메인 모델 vs. 빈약한 도메인 모델

- 유스케이스는 도메인 모델의 진입점으로 동작한다. 풍부한 도메인 모델인 경우, 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.
- 빈약한 도메인 모델에서는 엔티티 자체가 굉장회 얇다. 일반적으로 엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한 getter, setter 메소드만 포함하고 어떤 도메인 로직도 가지고 있지 않다.
- 앞의 두 가지 스타일을 비롯한 그 밖의 여러 가지 다른 스타일들도 이 책에서 논의하는 아키텍처 접근법을 이용해서 구현할 수 있다.

#### 유스케이스마다 다른 출력 모델

- 입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋다.

#### 읽기 전용 유스케이스는 어떨까?

- 이 책의 아키텍처 스타일에서 이를 구현하는 한 가지 방법은 쿼리를 위한 인커밍 전용 포트를 만들고 이를 '쿼리 서비스'에 구현하는 것이다.
- 읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 코드 상에서 명확하게 구분된다. 이런 방식은 CQS나 CQRS같은 개념과 아주 잘 맞는다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 입출력 모델을 독립적으로 모델링한다면 원치 않는 부수효과(다른 유스케이스에 영향을 미치는 것?)를 피할 수 있다. 
- 꼼꼼한 입력 유효성 검증, 유스케이스별 입출력 모델은 지속 가능한 코드를 만드는 데 큰 도움이 된다.

-------------------------------------------------------

### 5장 웹 어댑터 구현하기

#### 의존성 역전

- 웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터다.
- 컨트롤러가 구체 서비스(유스케이스)에 직접 의존하지 않는 의존성 역전이 적용. 그럼 왜 어댑터와 유스케이스 사이에 또 다른 간접 계층을 넣어야 할까? 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세가 포트이기 때문이다. 포트를 적절한 곳에 위치시키면 외부와 어떤 통신이 일어나고 있는지 정확히 알 수 있고, 이는 레거시 코드를 다루는 유지보수 엔지니어에게는 무척 소중한 정보다.

#### 웹 어댑터의 책임

- REST API를 제공하는 웹 어댑터를 가정해보자. 웹 어댑터는 일반적으로 아래의 책임을 가질 것이다.
	1. HTTP 요청을 자바 객체로 매핑
	2. 권한 검사
	3. 입력 유효성 검증
	4. 입력을 유스케이스의 입력 모델로 매핑
	5. 유스케이스 호출
	6. 유스케이스의 출력을 HTTP로 매핑
	7. HTTP 응답을 반환
- 웹 어댑터의 입력 모델은 웹 어댑터의 맥락에서 입력의 유효성을 검증해야 한다. 그리고 웹 어대텁의 입력 모델을 유스케으스의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.
- HTTP와 관련된 것은 애플리케이션 계층으로 침투해서는 안 된다. 우리가 바깥 계층에서 HTTP를 다루고 있다는 것을 애플리케이션 코어가 알게 되면 HTTP를 사용하지 않은 또 다른 인커밍 어댑터의 요청에 대해 동일한 도메인 로직을 수행할 수 있는 선택지를 잃게 된다.
- 웹 어댑터와 애플리케이션 계층 간의 이 같은 경계는 웹 계층에서부터 개발을 시작하는 대신 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스럽게 생긴다.

#### 컨트롤러 나누기

- 웹 어댑터는 한 개 이상의 클래스로 구성해도 된다.
- 각 컨트롤러가 가능한 한 좁고 다른 컨트롤러와 가능한 한 적게 공유하는 웹 어댑터 조각을 구현해야 한다.
- 특정 도메인에 관련된 모든 요청을 받는 거대한 컨트롤러의 단점
	- 클래스마다 코드는 적을수록 좋다.
	- 모든 연산을 단일 컨트롤러에 넣는 것은 데이터 구조의 재활용을 촉진한다.


#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 애플리케이션의 웹 어댑터를 구현할 때는 HTTP 요청을 애플리케이션의 유스케이스에 대한 메서드 호출로 변환하고 결과를 다시 HTTP로 변환하고 어떤 도메인 로직도 수행하지 않느 어댑터를 만들고 있다는 점을 염두에 둬야 한다.
- 웹 컨트롤러를 나눌 때는 모델을 공유하지 않는 여러 작은 클래스들을 만드는 것을 두려워해서는 안 된다.


-------------------------------------------------------


### 6장 영속성 어댑터 구현하기

#### 의존성 역전

- 애플리케이션 서비스에서는 영속성 기능을 가용하기 위해 포트 인터페이스를 호출한다. 이 포트는 실제로 영속성 작업을 수행하고 데이터베이스와 통신할 책임을 가진 영속성 어댑터 클래스에 의해 구현된다.
- 육각형 아키텍처에서 영속성 어댑터는 '주도되는' 혹은 '아웃고잉' 어댑터다.
- 포트는 사실상 애플리케이션 서비스와 영속성 코드 사이의 간접적인 계층이다.
- 자연스럽게 런타임에도 의존성은 애플리케이션 코어에서 영속성 어댑터로 향한다.

#### 영속성 어댑터의 책임

- 영속성 어댑터의 책임
	1. 입력을 받는다.
	2. 입력을 데이터베이스 포맷으로 매핑한다.
	3. 입력을 데이터베이스로 보낸다.
	4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
	5. 출력을 반환한다.
- 핵심은 영속성 어댑터의 입력 모델이 영속성 어댑터 내부에 있는 것이 아니라 애플리케이션 코어에 있기 때문에 영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않는다는 것이다.

#### 포트 인터페이스 나누기

- 서비스를 구현하면서 생기는 의문은 데이터베이스 연산을 정의하고 있는 포트 인터페이스를 어떻게 나눌 것인가다.
- 인터페이스 분리 원칙은 이 문제의 답을 제시한다.
```
인터페이스 분리 원칙: 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록  
넓은 인터페이스를 특화된 인터페이스로 분리해야 한다.
```
- 모든 상황에 '포트 하나당 하나의 메서드'를 적용하지는 못할 것이다. 응집성이 높고 함께 사용될 때가 많기 때문에 하나의 인터페이스에 묶고 싶은 데이터베이스 연산들이 있을 수 있다.

#### 영속성 어댑터 나누기

- 영속성 연산이 필요한 도메인 클래스 하나당 하나의 영속성 어댑터를 구현하는 방식을 선택할 수 있다. 이렇게 하면 영속성 어댑터들은 각 영속성 기능을 이용하는 도메인 경계를 따라 자동으로 나눠진다.
- 도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 총족시키는지에 관심이 없다는 사실을 기억하자.

#### 스프링 데이터 JPA 예제

#### 데이터베이스 트랜잭션은 어떻게 해야 할까?

- 트랜잭션 경계는 어디에 위치시켜야 할까? 영속성 어댑터는 어떤 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못하기 때문에 언제 트랜잭션을 ㅇ려고 닫을지 결정할 수 없다. 이 책임은 영속성 어댑터 호출을 관장하는 서비스에 위임해야 한다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면 도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 도메인 모델을 만들 수 있다.

-------------------------------------------------------

### 7장 아키텍처 요소 테스트하기

#### 테스트 피라미드

- 테스트 피라미드는 몇 개의 테스트와 어떤 종류의 테스트를 목표로 해야 하는지 결정하는 데 도움을 준다.

#### 단위 테스트로 도메인 엔티티 테스트하기

- 도메인 엔티티에 대한 단위 테스트는 만들고 이해하기 쉬운 편이고, 아주 빠르게 실행된다. 

#### 단위 테스트로 유스케이스 테스트하기

- 테스트는 시비스가 모킹된 의존 대상의 특정 메서드와 상호작용했는지 여부를 검증한다. 이는 테스트가 코드의 행동 변경뿐만 아니라 코드의 구조 변경에도 취약해진다는 의미가 된다.
- 테스트에서 어떤 상호작용을 검즈하고 싶은지 신중하게 생각해야 한다.

#### 통합 테스트로 웹 어댑터 테스트하기

- 웹 컨트롤러가 스프링 프레임워크에 강하게 묶여 있기 때문에 격리된 상태로 테스트하기보다는 이 프레임워크와 통합된 상태로 테스트하는 것이 합리적이다.

#### 통합 테스트로 영속성 어댑터 테스트하기

- 비슷한 이유로 영속성 어댑터의 테스트에는 단위 테스트보다는 통합 테스트를 적용하는 것이 합리적이다. 단순히 어댑터의 로직만 검늗하고 싶은 게 아니라 데이터베이스 매핑도 검증하고 싶기 때문이다.

#### 시스템 테스트로 주요 경로 테스트하기

- 피라미드의 최상단에 있는 시스템 테스트는 전체 애플리케이션을 띄우고 API를 통해 요청을 보내고, 모든 계층이 조화롭게 잘 동작하는지 검증한다.
- 도메인 특화 언어는 어떤 테스트에서도 유용하지만 시스템 테스트에서는 더욱 의미를 가진다.

#### 얼마만큼의 테스트가 충분할까요?

- 나는 얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼으면 된다고 생각한다.
- 우리가 만들어야 할 테스트를 정의하는 전략으로 시작하는 것도 좋다. 다음은 육각형 아키텍처에서 사용하는 전략이다.
	- 도메인 엔티티를 구현할 때는 단위 테스트로 커버하자
	- 유스케이스를 구현할 때는 단위 테스트로 커버하자
	- 어댑터를 구현할 때는 통합 테스트로 커버하자
	- 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버하자

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 육각형 아키텍처는 도메인 로직과 바깥으로 향한 어댑터를 깜끔하게 분리한다. 덕분에 핵심 도메인 로직은 단위 테스트로, 어댑터는 통합 테스트로 처리하는 명확한 테스트 전략을 정의할 수 있다.
- 모킹하는 것이 너무 버거워지거나 코드의 특정 부분을 커버하기 위해 어떤 종류의 테스트를 써야할지 모르겠다면 이는 경고 신호다.

-------------------------------------------------------


### 8장 경계 간 매핑하기

#### '매핑하지 않기'전략

- 모든 계층이 하나의 도메인 모델을 사용하는 전략
- 도메인 모델이 웹, 애플리케이션, 영속성 계층과 관련된 이유로 인해 변경돼야 하기 때문에 단일 책임 원칙을 위반
- 모든 계층이 정확히 같은 구조의, 정확시 같은 정보를 필요로 한다면 '매핑하지 않기'전략은 완벽한 선택지다.
- 그러나 애플리케이션 계층이나 도메인 계층에서 웹과 영속성 문제를 다루게 되면 곧바로 다른 전략을 취해야 한다.
- 저자의 경험에 의하면 많은 유스케이스들이 간단한 CRUD 유스케이스로 시작했다가 시간이 지남에 따라 값비싼 매핑 전략이 필요한, 풍부한 행동과 유효성 검증을 가진 제대로 된 비즈니스 유스케이스로 바뀌어 갔다.

#### '양방향'매핑 전략

- 각 계층이 전용 모델을 가진 매핑 전략
- 개념적으로 '매핑하지 않기'전략 다음으로 간단한 전략
- 그러나 너무 많은 보일러플레이트 코드가 생긴다. 또한 도메인 모델이 계층 경계를 넘어서 통신하는 데 사용된다.

#### '완전'매핑 전략

- 각 연산마다 별도의 입출력 모델을 사용하는 전략
- 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수하기가 훨씬 쉽다.
- 한 계층을 다른 여러 개의 커매드로 매핑하는 데는 하나의 웹 모델과 도메인 모델 간의 패밍보다 더 많은 코드가 필요하다.
- 이 전략은 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다. 애플리케이션 계층과 ㅇ여속성 계층 사이에서는 매핑 오버헤드 때문에 사용하지 않는 것이 좋다.

#### '단방향'매핑 전략

- 모든 계층의 모델들이 같은 인터페이스를 구현하는 전략
- 행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다.
- 이 전략에서 매핑 책임은 명확하다. 한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 이용할 수 있도록 다른 무언가로 매핑하는 것이다. 그러므로 각 계층은 한 방향으로만 매핑한다. 그래서 이 전략의 이름이 '단방향'매핑 전략인 것이다.
- 하지만 매핑이 계층을 넘나들며 퍼져 있기 때문에 이 전략은 다른 전략에 비해 개념적으로 어렵다.
- 이 전략은 계층 간의 모델이 비슷할 때 가장 효과적이다.

#### 언제 어떤 매핑 전략을 사용할 것인가?

- 그때그때 다르다.
- 언제 어떤 전략을 삿용할지 결정하려면 팀 내에서 합의할 수 있는 가이드라인을 정해둬야 한다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 동작하는 인커밍 포트와 아웃고잉 포트는 서로 다른 계층이 어떻게 통신해야 하는지를 정의한다.
- 각 유스케이스에 대해 좁은 포트를 사용하면 유스케이스마다 다른 매핑 전략을 사용할 수 있고, 다른 유스케이스에 영향을 미치지 않으면서 코드를 개선할 수 있기 때문에 특정 상황, 특정 시점에 최선의 전략을 선택할 수 있다.

-------------------------------------------------------

### 9장 애플리케이션 조립하기

#### 왜 조립까지 신경 써야 할까?

- 의존성이 올바른 방향을 가리키게 하기 위해서다.
- 그럼 우리의 객체 인스턴스를 생성할 책임은 누구에게 있을까? 그리고 어떻게 의존성 규칙을 어기지 않으면서 그렇게 할 수 있을까? 해답은 아키텍처에 대해 중립적이고 인스턴스 생성을 위해 모든 클래스에 대한 의존성을 가지는 설정 컴포넌트가 있어야 한다는 것이다.
- 설정 컴포넌트는 우리가 제공한 조각들로 애플리케이션을 조립하는 것을 책임진다. 이 컴포넌트는 다음과 같은 역할을 수행해야 한다.
	- 웹 어댑터 인스턴스 생성
	- HTTP 요청이 실제로 웹 어댑터로 전달되도록 보장
	- 유스케이스 인스턴스 생성
	- 웹 어댑터에 유스케이스 인스턴스 제공
	- 영속성 어댑터 인스턴스 생성
	- 유스케이스에 영속성 어댑터 인스턴스 제공
	- 영속성 어댑터가 실제로 데이터베이스에 접근할 수 있도록 보장
- 보다시피 책임이 굉장히 많다. 이것은 단일 책임 원칙을 위반하는 게 아닐까? 위반하는게 만다. 그러나 애플리케이션의 나머지 부분을 깔끔하게 유지하고 싶다면 이처럼 구성요소들을 연결하는 바깥쪽 컴포넌트가 필요하다.

#### 평범한 코드로 조립하기

- 자바에서는 애플리케이션이 main 메서드로부터 시작된다. main 메서드 안에서 웹 컨트롤러부터 영속성 어댑터까지, 필요한 모든 클래스의 인스턴스를 생성한 후 함께 연결한다.
- 평범한 코드로 조립하는 것은 몇가지 단점이 있다.
	- 구성해야할 컴포넌트들이 너무 많을 수 있다.
	- 각 클래스가 속한 패키지 외부에서 인스턴스를 생성하기 때문에 이 클래스들은 전부 public이어야 한다.

#### 스프링의 클래스패스 스캐닝으로 조립하기

- TBD

#### 스프링의 자바 컴피그로 조립하기

- TBD

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 애플리케이션 조립을 책임지는 전용 설정 컴포넌트를 만들면 애플리케이션이 이러한 책임으로부터 자유로워진다. 이 방식을 이용하면 서로 다른 모듈로부터 독립되어 코드 상에서 손쉽게 옮겨 다닐 수 있는 응집도가 매우 높은 모듈을 만들 수 있다. 하지만 늘 그렇듯이 설정 컴포넌트를 유지보수하는 데 약간의 시간을 추가로 들여야 한다.

-------------------------------------------------------


### 10장 아키텍처 경계 강제하기

#### 경계와 의존성

- 가장 안쪽의 계층에는 도메인 엔티티가 있다. 애플리케이션 계층은 애플리케이션 서비스 안에 유스케이스를 구현하기 위해 도메인 엔티티에 접근한다. 어댑터는 인커밍 포트를 통해 서비스에 접근하고, 반대로 서비스는 아웃고잉 포트를 통해 어댑터에 접근한다. 마지막으로 설정 계층은 어댑터와 서비스 객체를 생성할 팩터리를 포함하고 있고, 의존성 주입 메커니즘을 제공한다.

#### 접근 제한자

- 자바에는 4가지 접근 제한자: private, package-private, protected, public
- package-private는 왜 중요할까? 자바 패키지를 통해 클래스들을 응집적인 '모듈'로 만들어 주기 때문이다.

#### 컴파일 후 체크

- 의존성 규칙을 위반했는지 확인할 수단으로 컴파일 후 체크를 도입 
- ArchUnit은 이러한 체크를 도와주는 자바용 도구

#### 빌드 아티팩트

- 여러 개의 분리된 빌드 아티팩트로 나누는 몇 가지 선택지가 있다.
	- 설정, 어댑터, 애플리케이션 계층의 빌드 아티팩트로 이뤄진 기본적인 3개의 모듈 빌드 방식
	- 하나의 어댑터 모듈을 여러 개의 빌드 모듈로 쪼개서 어댑터당 하나의 모듈이 되게 할 수도 있다.
	- 도메인 엔티티가 포트에서 전송 객체로 사용되지 않는 경우라면 의존성 역전 원칙을 적용해서 포트 인터페이스만 포함하는 API 모듈을 분리해서 빼낼 수 있다.
	- 서비스만 가지고 있는 모듈과 도메인 엔티티만 가지고 있는 모듈로 쪼갤 수 있다.
- 빌드 모듈로 아키텍처 경계를 구분하는 것은 패키지로 구분하는 방식과 비교했을 때 몇 가지 장점이 있다.
	1. 빌드 도구가 순환 의존성을 극도록 싫어한다는 것이다.
	2. 빌드 모듈 방식에서는 다른 모듈을 고려하지 않고 특정 모듈의 코드를 격리한채로 변경할 수 있다.
	3. 모듈 간 의존성이 빌드 스크립트에 분명하게 선어돼 있기 때문에 새로 의존성을 추가하는 일은 우연이 아닌 의식적인 행동이 된다.
- 이런 장점에는 빌드 스크립트를 유지보수하는 비용을 수반하기 때문에 아키텍처를 여러 개의 빌드 모듈로 나누기 전에 아키텍처가 어느 정도는 안정된 상태여야 한다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 기본적으로 소프트웨어 아키텍처는 아키텍처 요소 간의 의존성을 관리하는 게 전부다.
- 아키텍처를 잘 유지해나가고 싶다면 의존성이 올바른 방향을 가리키고 있는지 지속저으로 확인해야 한다.
- 하나의 빌드 모듈 안에서 아키텍처 경계를 강제해야 하고, 패키지 구조가 허용하지 않아 package-private 제한자를 사용할 수 없다면 ArchUnit 같은 컴파일 후 체크 도구를 이용해야 한다.
- 아키텍처가 충분히 안정적이라고 느껴지면 아키텍처 요소를 독립적인 비드 모듈로 추출해야 한다.

-------------------------------------------------------


### 11장 의식적으로 지름길 사용하기

#### 왜 지름길은 깨진 창문 같은까?

- 깨진 창문 이론이 코드 작업에 적용될 때의 의미는 다음과 같다.
	- 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기가 쉽다.
	- 코딩 규칙을 많이 어긴 코드에서 작업할 떄 또 다른 규칙을 어기기도 쉽다.
	- 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉽다.

#### 깨끗한 상태로 시작할 책임

- 가능한 한 지름길을 거의 쓰지 않고 기술 부채를 지지않은 채로 프로젝트를 깨끗하게 시작하는 것이 중요하다.
- 그러나 때로는 지름길을 취하는 것이 더 실용적일 때도 있다. 이러한 의도적인 지름길에 대해서는 세심하게 잘 기록해둬야 한다.

#### 유스케이스 간 모델 공유하기

- 두 개의 유스케이스가 같은 모델을 공유하면 모델에 의해 결합되된다. 이는 단일 책임 원칙에서 이야기하는 '변경할 이유'를 공유하는 것이다.
- 유스케이스 간 입출력 모델을 공유하는 것은 유스케이스들이 기능적으로 묶여 있을 때 유효하다.(특정 세부사항을 변경할 경우 실제로 두 유스케이스 모두에 영향을 주고 싶은 것)
- 두 유스케이스가 서로 간에 미치는 영향 없이 독립적으로 진화해야 한다면 입출력 모델을 고유하는 방식은 지름길이 된다.

#### 도메인 엔티티를 입출력 모델로 사용하기

- 간단한 생성이나 업데이트 유스케이스에서는 유스케이스 인터페이스에 도메인 엔티티가 있는 것이 괜찮을지도 모른다.
- 하지만 유스케이스가 단순히 데이터베이스의 필드 몇 개를 업데이트하는 수준이 아니라 더 복잡한 도메인 로직을 구현해야 한다면 유스케이스 인터페이스에 대한 전용 입출력 모델을 만드렁야 한다. 왜냐하면 유스케이스의 변경이 도메인 엔티티까지 전파되길 바라진 않을 것이기 때문이다.
- 이 지름길이 위험한 이유는 많은 유스케이스가 간단한 생성 또는 업데이트 유스케이스로 시작해서 시간이 지나면서 족잡한 도메인 로직 괴물이 되어간다는 사실 때문이다.

#### 인커밍 포트 건너뛰기

- 인커밍 포트는 의존성 역전에 필수적인 요소는 아니다.
- 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 정의한다. 전용 인커밍 포트를 유지하면 한눈에 진입점을 식별할 수 있다.
- 인커밍 포트를 유지해야 하는 또 다른 이유는 아키텍처를 쉽게 강제할 수 있기 때문이다.
- 애플리케이션의 규모가 작거나 인커밍 어댑터가 하나빡에 없어서 모든 제어 흐름을 인커밍 포트의 도움 없이 단숨에 파악할 수 있다면 인커밍 포트가 없는 것이 편하다. 그러나 애플리케이션의 규모가 이후로도 게속 작게 유지되거나 인커밍 어댑터가 계속 하나밖에 없을것이라고 확실할 수 있을까?

#### 애플리케이션 서비스 건너뛰기

- 간단한 CRUD 유스케이스에서는 보통 애플리케이션 서비스가 도메인 로직없이 생성, 업데이트, 삭제 요청을 그대로 영속성 어댑터에 전달하기 때문에 구미가 당길 수 있다.
- 하지만 이 방법은 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유해야 한다.
- 나아가 애플리케이션 코어에 유스케이스라고 할 만한 것이 없어진다. 유스케이스가 엔티티를 단순히 생성, 업데이트, 삭제하는 것보다 더 많은 일을 하게 되면 애플리케이션 서비스를 만드다는 명확한 가이드라인을 팀에 정해둬야 한다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 경제적인 관점에서 지름길이 합리적일 때도 있다. 
- 모든 애플리케이션은 처음에는 작게 시작하기 때문에, 유스케이스가 단순한 CRUD 상태에서 벗어나느 시점이 언제인지에 대해 팀이 합의하는 것이 매우 중요하다.
- 어떤 경우든 아키텍처에 대해, 그리고 왜 특정 지름길을 선택했는가에 대한 기록을 남겨서 나중에 우리 자신 또는 프로젝트를 인계받는 이들이 이 결정에 대해 다시 평가할 수 있게 하자.

-------------------------------------------------------


### 12장 아키텍처 스타일 결정하기

#### 도메인이 왕이다

- 외부의 영향을 받지 않고 도메인 코드를 자유롭게 발전시킬 수 있다는 것은 육각형 아키텍처 스타일이 내세우는 가장 중요한 가치다.

#### 경험이 여왕이다

- 아키텍처 스타일에 대해서 괜찮은 결정을 내리는 유일한 방법은 다른 아키텍처 스타일을 경험해 보는 것이다. 그러면 이 경험이 다음 아키텍처 결정을 이끌어 줄 것이다.

#### 그때그때 다르다

- 어떤 아키텍처 스타일을 골라야 하는가에 대한 저자의 대답은 전문 컨설턴트의 "그때그때 달라요..."와 같다. 어떤 소프트웨어를 만드느냐에 따라서도 다르고, 도메인 코드의 역할에 따라서도 다르다. 팀의 경험에 따라서도 다르다. 그리고 최정적으로는 내린 결정이 마음에 다느냐에 따라서도 다르다.

-------------------------------------------------------


### 궁금한 내용이나, 더 알아보고 싶은 내용을 적어봅시다 🤔
```


